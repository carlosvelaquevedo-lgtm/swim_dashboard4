# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1McUyCbG1Oaz34jMhNBfkNuToxkYt7CAE
"""

import streamlit as st
import cv2
import numpy as np
import mediapipe as mp
from mediapipe.tasks import python
from mediapipe.tasks.python import vision
import tempfile, os, datetime, csv, statistics, urllib.request, zipfile
from collections import deque
import matplotlib.pyplot as plt

from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Image as RLImage
)
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.pagesizes import letter

# ===============================================================
# STREAMLIT SETUP
# ===============================================================
st.set_page_config("Swim Technique Dashboard", layout="wide")
st.title("üèä Freestyle Swimming Technique Analyzer")

# ===============================================================
# COACH UI CONTROLS
# ===============================================================
with st.sidebar:
    st.header("Coach Settings")

    IS_UNDERWATER = st.toggle("Underwater footage", False)
    STRICT_MODE = st.toggle("Strict scoring", False)
    SHOW_PREVIEW = st.toggle("Show frame preview", True)

    SMOOTHING_WINDOW = st.slider("Angle smoothing window", 3, 15, 7)
    FRAME_SKIP = st.slider("Frame skip (mobile)", 0, 3, 1)

# ===============================================================
# IDEAL RANGES
# ===============================================================
IDEAL_ELBOW = (70,120) if IS_UNDERWATER else (80,140)
IDEAL_KNEE  = (150,175) if IS_UNDERWATER else (155,175)

PENALTY_MULT = 1.2 if STRICT_MODE else 1.0

# ===============================================================
# HELPERS
# ===============================================================
def angle(a,b,c):
    ba, bc = np.array(a)-np.array(b), np.array(c)-np.array(b)
    return np.degrees(np.arccos(
        np.clip(np.dot(ba,bc)/(np.linalg.norm(ba)*np.linalg.norm(bc)+1e-6),-1,1)
    ))

def deviation(v, r):
    return max(r[0]-v, v-r[1], 0)

# ===============================================================
# MEDIAPIPE (CACHED)
# ===============================================================
@st.cache_resource
def load_model():
    model = "pose_landmarker_lite.task"
    url = "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task"
    if not os.path.exists(model):
        urllib.request.urlretrieve(url, model)

    opts = vision.PoseLandmarkerOptions(
        base_options=python.BaseOptions(model_asset_path=model),
        running_mode=vision.RunningMode.VIDEO,
        num_poses=1
    )
    return vision.PoseLandmarker.create_from_options(opts)

detector = load_model()

# ===============================================================
# VIDEO UPLOAD (MULTI)
# ===============================================================
uploads = st.file_uploader(
    "Upload freestyle swimming videos",
    type=["mp4","mov","avi"],
    accept_multiple_files=True
)

if not uploads:
    st.stop()

if not st.button("‚ñ∂ Run Analysis"):
    st.stop()

# ===============================================================
# PROCESS EACH VIDEO
# ===============================================================
outputs = []
progress = st.progress(0.0)

for vid_i, upload in enumerate(uploads):

    with tempfile.NamedTemporaryFile(delete=False, suffix=".mp4") as tmp:
        tmp.write(upload.read())
        video_path = tmp.name

    cap = cv2.VideoCapture(video_path)
    fps = cap.get(cv2.CAP_PROP_FPS) or 30
    w, h = int(cap.get(3)), int(cap.get(4))
    total = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

    ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    base = f"swim_{vid_i}_{ts}"
    out_vid = f"{base}.mp4"
    out_csv = f"{base}.csv"
    out_pdf = f"{base}.pdf"

    writer = cv2.VideoWriter(
        out_vid, cv2.VideoWriter_fourcc(*"mp4v"), fps, (w,h)
    )

    times, elbows, symm, scores = [], [], [], []

    buf_e = deque(maxlen=SMOOTHING_WINDOW)
    score_buf = deque(maxlen=5)

    frame_id = 0

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        frame_id += 1
        if frame_id % (FRAME_SKIP+1) != 0:
            continue

        t = frame_id / fps
        mp_img = mp.Image(
            image_format=mp.ImageFormat.SRGB,
            data=cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        )
        res = detector.detect_for_video(mp_img, int(t*1000))
        if not res.pose_landmarks:
            writer.write(frame)
            continue

        lm = res.pose_landmarks[0]
        P = lambda i: (int(lm[i].x*w), int(lm[i].y*h))

        LS, LE, LW = P(11), P(13), P(15)
        LH, LK, LA = P(23), P(25), P(27)
        RH, RK, RA = P(24), P(26), P(28)

        e = angle(LS,LE,LW)
        kl = angle(LH,LK,LA)
        kr = angle(RH,RK,RA)

        buf_e.append(e)
        e_s = statistics.mean(buf_e)
        sym = abs(kl-kr)

        penalty = (
            deviation(e_s, IDEAL_ELBOW)*0.4 +
            sym*0.4 +
            (deviation(kl,IDEAL_KNEE)+deviation(kr,IDEAL_KNEE))*0.2
        ) * PENALTY_MULT

        score = max(0,100-penalty)
        score_buf.append(score)
        score = statistics.mean(score_buf)

        times.append(t)
        elbows.append(e_s)
        symm.append(sym)
        scores.append(score)

        cv2.putText(frame,f"Score {int(score)}",(20,40),0,0.9,(0,255,0),2)
        writer.write(frame)

        if SHOW_PREVIEW and frame_id % 90 == 0:
            st.image(frame, channels="BGR")

        progress.progress((vid_i + frame_id/total)/len(uploads))

    cap.release()
    writer.release()
    os.remove(video_path)

    # ===========================================================
    # CSV
    # ===========================================================
    with open(out_csv,"w",newline="") as f:
        wcsv = csv.writer(f)
        wcsv.writerow(["time","elbow","symmetry","score"])
        for i in range(len(times)):
            wcsv.writerow([
                round(times[i],2),
                round(elbows[i],1),
                round(symm[i],1),
                round(scores[i],1)
            ])

    # ===========================================================
    # CHARTS
    # ===========================================================
    fig, ax = plt.subplots()
    ax.plot(times, scores)
    ax.set_title("Technique Score Over Time")
    fig.savefig("score.png")

    fig2, ax2 = plt.subplots()
    ax2.plot(times, symm)
    ax2.set_title("Symmetry Over Time")
    fig2.savefig("symmetry.png")

    # ===========================================================
    # PDF REPORT
    # ===========================================================
    doc = SimpleDocTemplate(out_pdf, pagesize=letter)
    styles = getSampleStyleSheet()
    elems = [
        Paragraph("<b>Freestyle Swim Technique Report</b>", styles["Title"]),
        Spacer(1,12),
        Paragraph(f"Average Score: {round(statistics.mean(scores),1)}", styles["Normal"]),
        Spacer(1,12),
        RLImage("score.png", width=400, height=200),
        Spacer(1,12),
        RLImage("symmetry.png", width=400, height=200),
        Spacer(1,12),
        Paragraph("Coach Notes:", styles["Heading2"]),
        Paragraph("‚Ä¢ Body position\n‚Ä¢ Catch timing\n‚Ä¢ Breathing symmetry", styles["Normal"])
    ]
    doc.build(elems)

    outputs.append((out_vid,out_csv,out_pdf))

# ===============================================================
# DOWNLOADS
# ===============================================================
st.success("Analysis complete!")

zip_name = "swim_results.zip"
with zipfile.ZipFile(zip_name,"w") as z:
    for o in outputs:
        for f in o:
            z.write(f)

with open(zip_name,"rb") as f:
    st.download_button("‚¨á Download ALL Results (ZIP)", f)